(define (make-interval a b)
  (if (> a b)
      '()
      (cons a (make-interval (+ a 1) b))))
(define (nth n l)
  (if (= n 0)
      (car l)
      (nth (- n 1) (cdr l))))

; mutating list operations
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
;(define (count-pairs x)
;  (if (not (pair? x))
;      0
;      (+ (count-pairs (car x))
;         (count-pairs (cdr x))
;         1)))

; count-pairs with dfs
(define (count-pairs x)
  (let ((visited '()))
    ; have we seen a pair?
    (define (already-seen elem)
      (define (iter set)
        (cond ((null? set) #f)
              ((eq? (car set) elem) #t)
              (else (iter (cdr set)))))
      (iter visited))
    ; add new seen pair
    (define (add-seen elem)
      (set! visited (cons elem visited)))
      
    ; actual counting
    (define (iter x)
      (if (or (not (pair? x)) (already-seen x))
          0
          (begin
            (add-seen x)
            (+
             (iter (car x))
             (iter (cdr x))
             1))))
    (iter x)))
(define t1 (list 1 2 3))
(define end (list 3))
(define t2 (cons end (cons 2 end)))
(define t33 (list 3))
(define t32 (cons t33 t33))
(define t3 (cons t32 t32))
(define t4 (make-cycle (list 1 2 3)))

; has a list a cycle using constant space
(define (has-cycle? l)
  (define (iter l1 l2)
    (cond ((or (null? l1)
               (null? l2) (null? (cdr l2)))
           #f)
          ((eq? l1 l2)
           #t)
          (else (iter (cdr l1) (cdr (cdr l2))))))
  (if (null? l)
      #f
      (iter l (cdr l))))

; queue implementation
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (make-queue) (cons '() '()))

; queue with procedure
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (set-front val)
      (set! front-ptr val))
    (define (set-rear val)
      (set! rear-ptr val))
    
    (define (dispatch m) 
      (cond ((eq? m 'front-ptr) front-ptr)
            ((eq? m 'rear-ptr) rear-ptr)
            ((eq? m 'set-front-ptr!) set-front)
            ((eq? m 'set-rear-ptr!) set-rear)
            (else (error "Unknown function" m))))
    dispatch))
(define (front-ptr queue) (queue 'front-ptr))
(define (rear-ptr queue) (queue 'rear-ptr))
(define (set-front-ptr! queue item) ((queue 'set-front-ptr!) item))
(define (set-rear-ptr! queue item) ((queue 'set-rear-ptr!) item))

(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue)))) 
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue))) 
(define (print-queue queue)
  (display (front-ptr queue)))

; deque implementation
(define (front-deque q) (car q))
(define (rear-deque q) (cdr q))
(define (set-front-deque! q item) (set-car! q item))
(define (set-rear-deque! q item) (set-cdr! q item))
(define (make-deque) (cons '() '()))
(define (empty-deque? q) (null? (front-deque q)))
(define (front-insert-deque! q item)
  (let ((new-pair (cons item (front-deque q))))
    (begin 
      (if (empty-deque? q)
          (set-rear-deque! q new-pair))
      (set-front-deque! q new-pair)
      q))) 
(define (front-delete-deque! q)
  (if (empty-deque? q)
      (error "Delete on empty deque")
      (begin 
        (set-front-deque! q (cdr (front-deque q)))
        (if (empty-deque? q)
            (set-rear-deque! q (front-deque q)))
        q)))
(define (rear-insert-deque! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-deque? queue)
           (set-front-deque! queue new-pair)
           (set-rear-deque! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-deque queue) new-pair)
           (set-rear-deque! queue new-pair)
           queue)))) 
; rear-delete-deque! braucht eine etwas andere Datenstruktur

;(define q (make-deque))
;(front-insert-deque! q 1)
;(front-insert-deque! q 2)
;(rear-insert-deque! q 3)
;(rear-delete-deque! q)
;(rear-delete-deque! q)

; tables
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
(define (make-table)
  (list '*table*))

; multidimensional table
(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)

; local table
(define (make-table)
  (let ((table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) false)
            ((equal? key (caar records)) (car records))
            (else (assoc key (cdr records)))))
    (define (lookup-rec key table)
      (if (null? key)
          ; looked up all keys
          (cdr table)
          (let ((record (assoc (car key) (cdr table))))
             (if record
                 (lookup-rec (cdr key) record)
                 false))))
    
    (define (insert-rec! key value table)
      (if (null? (cdr key))
          ; arrived at the correct subtable
          (let ((record (assoc (car key) (cdr table))))
            (if record
                (set-cdr! record value)
                (set-cdr! table
                          (cons (cons (car key) value) (cdr table)))))
          ; step down into subtable
          (let ((subtable (assoc (car key) (cdr table))))
            (if (not subtable)
                (begin
                  (set! subtable (list (car key)))
                  (set-cdr! table (cons subtable (cdr table)))))
            (insert-rec! (cdr key) value subtable)))
      'do)
    (define (dispatch m)
      (cond ((eq? m 'lookup)  (lambda (key) (lookup-rec key table)))
            ((eq? m 'insert!) (lambda (key value) (begin (insert-rec! key value table) table)))
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))
(define (lookup key table)
  ((table 'lookup) (list key)))
(define (insert! key value table)
  ((table 'insert!) (list key) value))

(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))

; wire simulation
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))
(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))

; time simulation
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))

(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
(define (empty-agenda? agenda)
  (null? (segments agenda)))

(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))

(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))

(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))

; circuit simulation: gates
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
(define (logical-and a b)
  (if (= a 0)
      0
      (if (= b 0)
          0
          1)))
(define (or-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-or (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
(define (logical-or a b)
  (if (= a 1)
      1
      (if (= b 1)
          1
          0)))
;(define (or-gate a1 a2 output)
;  (let ((inv1 (make-wire))
;        (inv2 (make-wire))
;        (and (make-wire)))
;    (inverter a1 inv1)
;    (inverter a2 inv2)
;    (and-gate inv1 inv2 and)
;    (inverter and output)))

; General ripple adder
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
(define (ripple-carry-adder a b s c)
  (define carrys 
    (append (map (lambda (i) (make-wire)) (make-interval 1 (length a)))
            (list c)))
  
  ; wire the adders together
  (define (iter a b s c)
    (if (not (null? a))
        (begin
          (full-adder (car a) (car b) (car c) (car s) (cadr c))
          (iter (cdr a) (cdr b) (cdr s) (cdr c)))))
  (iter a b s carrys))
;(define (ripple-carry-adder
    

; simulation main
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
(define (probe name wire)
  (add-action! wire
               (lambda ()        
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))

(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)

; test adder
;(define a1 (make-wire))
;(define a2 (make-wire))
;(define b1 (make-wire))
;(define b2 (make-wire))
;(define carry-in (make-wire))
;(define carry-out (make-wire))
;(define sum1 (make-wire))
;(define sum2 (make-wire))
;(probe "sum1" sum1)
;(probe "sum2" sum2)
;(probe "carry" carry-out)
;(ripple-carry-adder (list a1 a2) (list b1 b2) (list sum1 sum2) carry-out)
;
;(set-signal! a1 1)
;(set-signal! a2 0)
;(set-signal! b1 1)
;(set-signal! b2 0)
;(propagate)

; constraint network
(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me)
  me)

(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))

; connectors
(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Unknown operation -- CONNECTOR"
                         request))))
    me))
(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))

; Avg constraint
(define (average a b c)
  (let ((two (make-connector))
        (right (make-connector)))
    (constant 2 two)
    (multiplier c two right)
    (adder a b right)))

; constraint programming
;(define (celsius-fahrenheit-converter c f)
;  (let ((u (make-connector))
;        (v (make-connector))
;        (w (make-connector))
;        (x (make-connector))
;        (y (make-connector)))
;    (multiplier c w u)
;    (multiplier v x u)
;    (adder v y f)
;    (constant 9 w)
;    (constant 5 x)
;    (constant 32 y)
;    'ok))
;
;(define C (make-connector))
;(define F (make-connector))
;(probe "Celsius temp" C)
;(probe "Fahrenheit temp" F)
;(celsius-fahrenheit-converter C F)

(define a (make-connector))
(probe "A" a)
(define b (make-connector))
(probe "B" b)
;(define c (make-connector))
;(probe "C" c)
;(average a b c)

(define (squarer a b)
  (multiplier a a b))
(squarer a b)