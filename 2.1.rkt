; rational numbers
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

; constructor, selector
(define (make-rat n d) 
  (let ((g (gcd n d)))
    (let ((n-red (/ n g))
          (d-red (/ d g)))
      (if  (< d-red 0) 
           (cons (- n-red) (- d-red))
           (cons n-red d-red)))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

; operations
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

; line segment
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (make-segment start end)
  (cons start end))
(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (cdr segment))

; operations
(define (add-point p1 p2)
  (make-point (+ (x-point p1) (x-point p2))
              (+ (y-point p1) (y-point p2))))
(define (div-point p num)
  (make-point (/ (x-point p) num)
              (/ (y-point p) num)))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(define (midpoint-segment segment)
  (let ((p1 (start-segment segment))
        (p2 (end-segment segment)))
    (div-point (add-point p1 p2) 2)))

; rect
(define (make-rect p1 p2)
  (let ((x1 (x-point p1))
        (y1 (y-point p1))
        (x2 (x-point p2))
        (y2 (y-point p2)))
    (let ((xl (min x1 x2))
          (xr (max x1 x2))
          (yl (min y1 y2))
          (yr (max y1 y2)))
      (cons (make-point xl yl)
            (make-point xr yr)))))
(define (width-rect r)
  (let ((p1 (car r))
        (p2 (cdr r)))
    (let ((xl (x-point p1))
          (xr (x-point p2)))
      (- xr xl))))
(define (height-rect r)
  (let ((p1 (car r))
        (p2 (cdr r)))
    (let ((xl (x-point p1))
          (xr (x-point p2)))
      (- xr xl))))
(define (perimeter-rect r)
  (* 2 (+ (width-rect r)
          (height-rect r))))
(define (area-rect r)
  (* (width-rect r)
     (height-rect r)))

(define p1 (make-point 1 3))
(define p2 (make-point 0 4))
(define r (make-rect p1 p2))

; cons1
;(define (cons x y)
;  (lambda (m) (m x y)))
;
;(define (car z)
;  (z (lambda (p q) p)))
;(define (cdr z)
;  (z (lambda (p q) q)))

; cons 2
;(define (cons x y)
;  (* (expt 2 x)
;     (expt 3 y)))
; times-in: numbers of times a factor is in a number
;(define (times-in num f)
;  (if (= (remainder num f) 0)
;      (+ 1 (times-in (/ num f) f))
;      0))
;(define (car p)
;  (times-in p 2))
;(define (cdr p)
;  (times-in p 3))

; church numerals
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

(define one
  (lambda (f) (lambda (x) (f x))))
(define two
  (lambda (f) (lambda (x) (f (f x)))))

(define (add n m)
  (lambda (f) (lambda (x) ((n f) ((m f) x)))))

; interval arithmetic
(define (make-interval a b) 
  (let ((l (min a b))
        (r (max a b)))
    (cons l r)))
(define (lower-bound x)
  (car x))
(define (upper-bound x)
  (cdr x))
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (sub-interval x y)
  (make-interval (- (upper-bound x) (lower-bound y))
                 (- (lower-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (let ((r (upper-bound y))
        (l (lower-bound y)))
    (if (or (= r 0) (= l 0))
        (error "Division by zero")
        (mul-interval x 
                      (make-interval (/ 1.0 r)
                                     (/ 1.0 l))))))

; alternative constructors
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
(define (make-center-percent c p)
  (make-center-width c (* c (/ p 100))))
(define (percent i)
  (* 100 (/ (width i) (center i))))

; parallel resistors
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1))) 
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))

(define i1 (make-center-percent 1.0 3))
(define i2 (make-center-percent 3.0 5))