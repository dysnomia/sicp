(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
(define (memq-front item x)
  (define (iter rest front)
    (cond ((null? rest) false)
          ((eq? item (car rest)) (reverse front))
          (else (iter (cdr rest) (cons (car rest) front)))))
  (iter x '()))

; equal lists of symbols
;(define (equal? l1 l2)
;  (if (and (pair? l1)
;           (pair? l2))
;      ; both empty
;      (if (or (null? l1) (null? l2))
;          (and (null? l1) (null? l2))
;          ; recursive equality test
;          (and (equal? (car l1) (car l2))
;               (equal? (cdr l1) (cdr l2))))
;      ; both elementary symbols
;      (eq? l1 l2)))

; symbolic differentiation
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ;((exponentiation? exp)
        ; (make-product
        ;  (exponent exp)
        ;  (make-exponentiation
        ;   (base exp)
        ;   (make-sum (exponent exp) -1))))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type -- DERIV" exp))))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
;(define (make-sum a1 a2)
;  (cond ((=number? a1 0) a2)
;        ((=number? a2 0) a1)
;        ((and (number? a1) (number? a2)) (+ a1 a2))
;        (else (list '+ a1 a2))))
;(define (make-sum a1 a2)
;  (cond ((=number? a1 0) a2)
;        ((=number? a2 0) a1)
;        ((and (number? a1) (number? a2)) (+ a1 a2))
;        (else (list '+ a1 a2))))
;(define (make-product m1 m2)
;  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
;        ((=number? m1 1) m2)
;        ((=number? m2 1) m1)
;        ((and (number? m1) (number? m2)) (* m1 m2))
;        (else (list '* m1 m2))))
;(define (sum? x)
;  (and (pair? x) (eq? (car x) '+)))
;(define (addend s) (cadr s))
;(define (augend s) 
;  (if (null? (cdddr s))
;      (caddr s)
;      (cons '+ (cddr s))))
;(define (product? x)
;  (and (pair? x) (eq? (car x) '*)))
;(define (multiplier p) (cadr p))
;(define (multiplicand p) 
;  (if (null? (cdddr p))
;      (caddr p)
;      (cons '* (cddr p))))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))
(define (base x) (cadr x))
(define (exponent x) (caddr x))
(define (make-exponentiation base exp)
  (cond ((=number? exp 0) 1)
        ((=number? exp 1) base)
        ((=number? base 0) 0)
        (else (list '** base exp))))
        
; infix version
(define (unwrap l)
  (if (null? (cdr l)) (car l) l))
(define (sum? x)
  (and (pair? x) (memq '+ x)))
(define (addend s) (unwrap (memq-front '+ s)))
(define (augend s) (unwrap (cdr (memq '+ s))))
(define (product? x)
  (and (pair? x) (memq '* x)))
(define (multiplier p) (unwrap (memq-front '* p)))
(define (multiplicand p) (unwrap (cdr (memq '* p))))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))

; set representation: unordered list, no duplicates
;(define (element-of-set? x set)
;  (cond ((null? set) false)
;        ((equal? x (car set)) true)
;        (else (element-of-set? x (cdr set)))))
;(define (adjoin-set x set)
;  (if (element-of-set? x set)
;      set
;      (cons x set)))
;(define (intersection-set set1 set2)
;  (cond ((or (null? set1) (null? set2)) '())
;        ((element-of-set? (car set1) set2)        
;         (cons (car set1)
;               (intersection-set (cdr set1) set2)))
;        (else (intersection-set (cdr set1) set2))))
;(define (union-set s1 s2)
;  (append s1 s2))

; set: unordered list, duplicates
;(define (element-of-set? x set)
;  (cond ((null? set) false)
;        ((equal? x (car set)) true)
;        (else (element-of-set? x (cdr set)))))
;(define (adjoin-set x set)
;      (cons x set))
;(define (intersection-set set1 set2)
;  (cond ((or (null? set1) (null? set2)) '())
;        ((element-of-set? (car set1) set2)        
;         (cons (car set1)
;               (intersection-set (cdr set1) set2)))
;        (else (intersection-set (cdr set1) set2))))
;(define (union-set s1 s2)
;  (append s1 s2))

; sets: ordered list
;(define set1 '(1 3 4 8 10))
;(define set2 '(3 4 5 9 12))
;(define (element-of-set? x set)
;  (cond ((null? set) false)
;        ((= x (car set)) true)
;        ((< x (car set)) false)
;        (else (element-of-set? x (cdr set)))))
(define (intersection-ordered-list set1 set2)
  (if (or (null? set1) (null? set2))
      '()    
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-ordered-list (cdr set1)
                                       (cdr set2))))
              ((< x1 x2)
               (intersection-ordered-list (cdr set1) set2))
              ((< x2 x1)
               (intersection-ordered-list set1 (cdr set2)))))))
;(define (adjoin-set x set)
;  (cond ((null? set) (list x))
;        ((< x (car set)) (cons x set))
;        ((= x (car set)) set)
;        ; > x (car set)
;        (else (cons (car set) (adjoin-set x (cdr set))))))
(define (union-ordered-list set1 set2)
  (if (or (null? set1) (null? set2))
      (append set1 set2)    
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (union-ordered-list (cdr set1)
                                       (cdr set2))))
              ((< x1 x2)
               (cons x1
                     (union-ordered-list (cdr set1) set2)))
              ((< x2 x1)
               (cons x2
                     (union-ordered-list set1 (cdr set2))))))))

; set: trees
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set) 
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
(define tree1 '(7 (3 (1 () ()) (5 () ()))
                  (9 () (11 () ()))))
(define tree2 '(3 (1 () ()) (7 
                             (5 () ()) 
                             (9 () (11 () ())))))
(define tree3 '(5 (3 (1 () ()) ())
                  (9 (7 () ()) (11 () ()))))

(define (list->tree elements)
  (car (partial-tree elements (length elements))))

; partial first constructs the left 
; subtree, then chooses the next element in the
; middle and then constructs the right subtree
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree)
                      remaining-elts))))))))


(define (union-set s1 s2)
  (let ((l1 (tree->list-2 s1))
        (l2 (tree->list-2 s2)))
    (list->tree (union-ordered-list l1 l2))))
(define (intersection-set s1 s2)
  (let ((l1 (tree->list-2 s1))
        (l2 (tree->list-2 s2)))
    (list->tree (intersection-ordered-list l1 l2))))
(define (lookup key set)
  (cond ((null? set) false)
        ((= key (entry set)) (entry set))
        ((< key (entry set))
         (lookup key (left-branch set)))
        ((> key (entry set))
         (lookup key (right-branch set)))))

; Huffman trees
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
(define (left-branch tree) (car tree))

(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

; decode Huffman coding
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))

; build Huffman tree
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ; symbol
                               (cadr pair))  ; frequency
                    (make-leaf-set (cdr pairs))))))

; encode message
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
(define (encode-symbol symbol tree)
  (if (leaf? tree)
      (if (not (eq? symbol (symbol-leaf tree)))
             (error "Symbol not in tree")
             '())
      (let ((left-symbols (symbols (left-branch tree)))
            (right-symbols (symbols (right-branch tree))))
        (cond ((element-of-set? symbol left-symbols)
               (cons 0 (encode-symbol symbol (left-branch tree))))
              ((element-of-set? symbol right-symbols)
               (cons 1 (encode-symbol symbol (right-branch tree))))
              (else (error "Symbol not in tree"))))))

; Create huffman tree
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
(define (successive-merge tree)
  (define (merge tree)
    (if (null? (cdr tree))
        ; tree finished
        (car tree)
        (let ((rest (cddr tree))
              (new (make-code-tree (car tree) (cadr tree))))
          (merge (adjoin-set new rest)))))
  (merge tree))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(define rock-freq '((a 2) (boom 1) (Get 2) (job 2) (na 16) (Sha 3) (yip 9) (Wah 1)))
(define rock-tree (generate-huffman-tree rock-freq))